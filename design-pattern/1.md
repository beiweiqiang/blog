# 结构型模式 -- 适配器模式

用于解决不兼容结构问题.

在适配器模式中引入了一个被称为适配器(Adapter)的包装类, 而它所包装的对象称为适配者(Adaptee), 即被适配的类.

适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用.

适配器模式可以将一个类的接口和另一个类的接口匹配起来, 而无须修改原来的**适配者接口**和**抽象目标类接口**.

> 定义: 将一个接口转换成客户希望的另一个接口, 使接口不兼容的那些类可以一起工作, 其别名为包装器(Wrapper).

适配器模式中, 我们通过增加一个新的 **适配器类** 来解决接口不兼容的问题, 使得原本没有任何关系的类可以协同工作.

根据 **适配器类** 与 **适配者类** 关系不同, 适配器模式可以分为 **对象适配器** 和 **类适配器** 两种.

### 对象适配器

在 **对象适配器** 模式中, 适配器与适配者是 **关联关系**. (比如学生与身份证)

在 **类适配器** 模式中, 适配器与适配者是 **继承(或实现)关系**.(比如车与自行车)

> 在实际开发中, 对象适配的使用频率更高.

对象适配器模式如下图:
![img](http://img.my.csdn.net/uploads/201302/28/1362066399_9469.jpg)

对象适配器模式结构图包含如下几个角色:

- Target(目标抽象类): 定义客户所需接口, 可以是一个抽象类或接口, 也可以是具体类.

- Adapter(适配器类): 适配器可以调用另一个接口, 作为一个转换器, 对 Adaptee 和 Target 进行适配. 它通过 **继承 Target 并关联一个 Adaptee 对象** 使二者产生联系.

- Adaptee(适配者类): 适配者即被适配的角色, 它定义了一个已经存在的接口, 这个接口需要适配.

在上图对象适配器中, 客户端需要调用 request() 方法, 而适配者类 Adaptee 没有该方法, 但是它所提供的 specificRequest() 方法是客户端所需要的.

为了使客户端能够使用适配者类, 需要提供一个包装类 Adapter, 即适配器类.

这个包装类包装了一个适配者的实例, 从而将客户端与适配者衔接起来, 在适配器的 request() 方法中调用适配者的 specificRequest() 方法.

因为适配器与适配者类是关联关系(也可称之为委派关系), 称为对象适配器模式.

```java
class Adapter extends Target {
  private Adaptee adaptee;

  public Adapter(Adaptee adaptee) {
    this.adaptee = adaptee;
  }

  public void request() {
    adaptee.specificRequest();
  }
}
```

### 类适配器

类适配器模式 和 对象适配器模式 最大的区别在于 **适配器** 和 **适配者** 之间的关系不同.

对象适配器模式: 关联关系

类适配器模式: 继承关系

类适配器模式结构图:

![img](http://img.my.csdn.net/uploads/201303/01/1362099343_7447.jpg)

在类适配器模式结构图中, 适配器类 **实现** 了抽象目标类接口 Target, 并 **继承** 了适配者类, 在适配器类的 request() 方法中调用所继承的适配者类的 specificRequest() 方法.

```java
class Adapter extends Adaptee implements Target {
  public void request() {
    specificRequest();
  }
}
```

约束:

Java, C#等语言不支持多重类继承.

如果目标抽象类 Target 不是接口而是一个类, 无法用类适配器.

如果适配者 Adaptee 为 Final 类, 无法使用类适配器.

### 双向适配器

在 **对象适配器** 中, 如果在适配器中同时包含对目标类和适配者类的引用, 适配者可以通过它调用目标类中的方法, 目标类也可以通过它调用适配者类中的方法, 该适配器就是一个双向适配器.

(也就是 适配者 和 目标抽象类 可以互相调用)

(是基于对象适配器的)

![img](http://img.my.csdn.net/uploads/201303/01/1362100282_9857.jpg)

代码实现:
```java
class Adapter implements Target, Adaptee {
  // 同时维护对 目标抽象类 和 适配者类 的引用
  private Target target;
  private Adaptee adaptee;

  public Adapter(Target target) {
    this.target = target;
  }

  public Adapter(Adaptee adaptee) {
    this.adaptee = adaptee;
  }

  public void request() {
    adaptee.spcificRequest();
  }

  public void specificRequest() {
    target.request();
  }
}
```

实际开发中很少用到双向适配器.

### 缺省适配器

缺省适配器模式: 当不需要实现一个接口所提供的所有方法时, 可先设计一个 **抽象类** 实现该接口, 并为接口中的 **每个方法提供一个默认实现(空方法)**, 那么该抽象类的子类可以 **选择性** 地覆盖父类的某些方法来实现需求, 它适用于不想使用一个接口中的所有方法的情况, 又称为单接口适配器模式.

缺省适配器模式结构:

![img](http://img.my.csdn.net/uploads/201303/01/1362101177_9180.jpg)

包含三个角色:

- ServiceInterface (适配者接口): 一个接口, 该接口声明了大量的方法.

- AbstractServiceClass (缺省适配器类): 核心类, 使用空方法的形式实现了在 ServiceInterface 接口中声明的方法. **通常将它定义为抽象类, 因为它进行实例化没有任何意义.**

- ConcreteServiceClass (具体业务类): 缺省适配器类的子类, 在没有引入适配器之前, 它需要实现适配者接口, 因此需要实现在适配者接口中定义的所有方法, 而对一些无须使用的方法也不得不提供空实现. 有了缺省适配器之后, 可以直接继承该适配器类, 根据需要有选择性地覆盖在适配器类中定义的方法.

### 总结

#### 优点

无论对象适配器还是类适配器, 优点:

1. 抽象目标类 和 适配者类 解耦, 引入一个适配器类来重用现有的适配者类.

2. 增加了类的透明性和复用性, 将具体的业务实现过程封装在 **适配者类**, 对于客户端是透明的, 提高了适配者的复用性, 同一个 **适配者类** 可以再多个不同的系统中复用.

3. 通过配置文件, 可以很方便地更换适配器, 也可以再不修改原有代码的基础上增加新的适配器类.

对象适配器模式 还有优点:

1. 一个对象适配器可以把 **多个不同的适配者** 适配到同一个目标.

2. 可以适配一个适配者的子类, 由于适配器和适配者之间是 **关联关系**, 根据 "里氏代换原则", 适配者的子类也可通过该适配器进行适配.

#### 缺点

类适配器模式的缺点:

1. 对于不支持多重类继承的语言, 一次最多只能适配一个适配者类.

2. 适配者类不能为最终类

3. 在 Java, C# 等语言中, 类适配器模式中的目标抽象类 **只能为接口**, 不能为类.

对象适配器模式的缺点:

1. 与类适配器模式相比, 要在适配器中置换适配者类的某些方法比较麻烦. 如果一定要置换掉适配者类的一个或多个方法, 可以先做一个 **适配者类的子类**, 将适配者类的方法置换掉, 然后再把适配者类的子类当做真正的适配者进行适配.


