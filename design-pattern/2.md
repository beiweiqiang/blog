# 行为型模式 -- 观察者模式 (Observer Pattern)

## 概要

一个对象的状态或行为的变化将导致其他对象的状态或行为也发生变化, 它们之间将产生 **联动**.

如何实现对象之间的联动? 如何让一个对象的状态或行为改变时, 依赖于它的对象能够得到通知并进行相应的处理?

观察者模式用于建立一种对象与对象之间的依赖关系, 一个对象发生改变时将 **自动** 通知其他对象, 其他对象将相应作出反应.

观察者模式中, 发生改变的对象称为 **观察目标**, 而被通知的对象称为 **观察者**, 一个观察目标可以对应 **多个** 观察者, 而且这些观察者之间可以没有任何相互联系, 可以根据需要增加和删除观察者, 系统易于扩展.

## 观察者模式定义 (Observer Pattern)

定义对象之间的一种一对多依赖关系, 使得每当一个对象状态发生改变时, 其相关依赖对象皆得到通知并被自动更新.

观察者模式的别名包括 发布-订阅(Publish/Subscribe)模式, 模型-视图(Model/View)模式, 源-监听器(Source/Listener)模式 或 从属者(Dependents)模式.

观察者模式结构中通常包括观察目标和观察者两个继承层次结构:

![img](http://my.csdn.net/uploads/201207/05/1341501815_4830.jpg)

观察者模式结构图中包含如下几个角色:

- Subject(目标): 又称为主题, 是指被观察的对象. 在目标中定义了一个 **观察者的集合**, 一个观察目标可以接受任意数量的观察者, 提供一系列方法来增加和删除观察者对象, 同时定义了通知方法 notify(). 目标类可以是接口, 也可以是抽象类或具体类.

- ConcreteSubject(具体目标): 具体目标是 **目标的子类**, 通常它包含有经常发生改变的数据, 当它的状态发生改变时, 向它的各个观察者发出通知, 同时它还实现了在目标类中定义的抽象业务逻辑方法(如果有). 如果无须扩展目标类, 则具体目标可以省略.

- Observer(观察者): 观察者将对观察目标的改变做出反应, **观察者一般定义为接口**, 该接口声明了更新数据的方法 update(), 又称为抽象观察者.

- ConcreteObserver(具体观察者): **在具体观察者中维护一个指向具体目标对象的引用, 它存储具体观察者的有关状态, 这些状态需要和具体目标的状态保持一致.** 它实现了在抽象观察者 Observer 中定义的 update() 方法. 通常在实现时, 可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除.

观察者模式描述了如何建立对象与对象之间的依赖关系, 如何构造满足这种需求的系统.

观察者模式包含 **观察目标** 和 **观察者** 两类对象, 一个目标可以有任意数目的与之相依赖的观察者, 一旦观察目标的状态发生改变, 所有的观察者都将得到通知.

作为对这个通知的响应, 每个观察者都将监视观察目标的状态以使其 **状态与目标状态同步**, 这种交互也称为 发布-订阅(Publish-Subscribe). 观察目标是通知的发布者, 它发出通知时并不需要知道谁是它的观察者, 可以有任意数目的观察者订阅它并接收通知.

定义一个抽象目标 Subject:

```java
abstract class Subject {
    protected ArrayList<Observer> observers = new ArrayList();

    public void attach(Observer observer) {
        observers.add(observer);
    }

    public void detach(Observer observer) {
        observers.remove(observer);
    }

    public abstract void notifyObservers();

}
```

具体目标:

```java
public class ConcreteSubject extends Subject {
    public void notifyObservers() {
        for (Object obs :
                observers) {
            ((Observer) obs).update();
        }
    }
}
```

抽象观察者 Observer, 一般定义为一个接口, 通常只声明一个 update() 方法, 为不同观察者的更新(响应)行为定义相同的接口, 这个方法在其子类中实现, 不同的观察者具有不同的响应方法:

```java
interface Observer {
    public void update();
}
```

具体观察者:

```java
public class ConcreteObserver implements Observer {
    public void update() {
        System.out.println("update!");
    }
}
```

在有些更加复杂的情况下, 具体观察者类(ConcreteObserver)的 update() 方法在执行时需要使用到具体目标类(ConcreteSubject) 中的状态(属性), 因此在 ConcreteObserver 与 ConcreteSubject 之间有时候还存在 **关联或依赖** 的关系, 在 ConcreteObserver 中定义一个 ConcreteSubject 实例, 通过该实例获取存储在 ConcreteSubject 中的状态.

如果 ConcreteObserver 的 update() 方法不需要使用到 ConcreteSubject 中的状态属性, 在 ConcreteObserver 和 ConcreteSubject 之间无须维持对象引用.

## JDK 对观察者模式的支持

在 JDK 的 java.util 包中, 提供了 Observable类 以及 Observer 接口.

![img](http://my.csdn.net/uploads/201207/06/1341504430_1842.jpg)

### Observer

在 java.util.Observer 接口中只声明一个方法, 充当抽象观察者:

```java
void update(Observable o, Object arg);
```




